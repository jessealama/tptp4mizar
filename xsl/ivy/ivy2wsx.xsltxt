stylesheet "1.0";
include "../tstp/tstp2wsx.xsl";
output method="xml" indent="yes";

tpl [formula[source/non-logical-data[@name = "inference"]/non-logical-data[@name = "resolve"]]] {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      apply [*[1]];
    }
    <Block {
      @kind = "Proof";
      for-each [*[1]] {
        for-each [descendant::variable[not(@name = preceding::variable/@name)]] {
          <Item {
            @kind = "Generalization";
            <Implicitly-Qualified-Segment {
              <Variable {
                @spelling = `@name`;
              }
            }
          }
        }
      }
      // Grab the first premise, then conclude from the second
      for-each [source] {
        for-each [non-logical-data[@name = "inference"]] {
          for-each [non-logical-data[position() = last()]] {
            if [non-logical-data[3]] {
              apply [.] (#message = "We found a resolution step that refers to more than 2 formulas.") mode="die";
            }
            if [not(non-logical-data[2])] {
              apply [.] (#message = "We found a resolution step that refers to fewer than 2 formulas.") mode="die";
            }
            for-each [non-logical-data] {
              $premise-name = `@name`;
              choose {
                when [position() = 1] {
                  if [not(key ("formulas", $premise-name))] {
                    $message = `concat ("Error: unable to find the premise '", $premise-name, "'.")`;
                    apply [.] (#message = $message) mode="die";
                  }
                  for-each [key ("formulas", $premise-name)] {
                    <Item {
                      @kind = "Regular-Statement";
                      @shape = "Compact-Statement";
                      // stripping the entire universal prefix may not be safe...
                      <Proposition {
                        apply [*[1]] mode="strip-universal-prefix";
                      }
                      <Straightforward-Justification {
                        <Local-Reference {
                          @spelling = $premise-name;
                        }
                      }
                    }
                  }
                }
                when [position() = 2] {
                  <Item {
                    @kind = "Conclusion";
                    @shape = "Compact-Statement";
                    <Proposition {
                      <Thesis;
                    }
                    <Straightforward-Justification {
                      <Link;
                      <Local-Reference {
                        @spelling = $premise-name;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
