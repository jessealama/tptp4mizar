stylesheet "1.0";
output method="xml" indent="yes";

//////////////////////////////////////////////////////////////////////
// Stylesheet parameters
//////////////////////////////////////////////////////////////////////

// A list of recommendations to try
#recommendations = { ""; }

//////////////////////////////////////////////////////////////////////
// Keys
//////////////////////////////////////////////////////////////////////

key "labelled-formulas" [Item[Proposition/Label[@spelling]]] `Proposition/Label[@spelling]/@spelling`;

//////////////////////////////////////////////////////////////////////
// Utilities
//////////////////////////////////////////////////////////////////////

tpl [*] mode="trace" {
  msg "We are about to terminate the XSLT processor.  Here's where we are:";
  apply [.] mode="trace-recursive";
}

tpl [*] mode="trace-recursive" {
  $n = `name (.)`;
  $position = `count (preceding-sibling::*[name() = $n]) + 1`;
  if [parent::*] {
    apply [..] mode="trace-recursive";
  }
  `$n`; "["; `$position`; "]"; "\n";
}

tpl [*] (#message) mode="die" {
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

tpl [/] {
  if [Text-Proper] {
    apply [Text-Proper];
  } else {
    msg terminate="yes" "Error: the Text-Proper root element is missing.";
  }
}

tpl [*] {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [*] mode="copy" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="copy";
  }
}

tpl fragile-recommendation-applied-to-any (#candidates) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $candidate-line = `$candidate/@line`;
    $candidate-col = `$candidate/@col`;
    $token = `concat (",", $candidate-line, ":", $candidate-col, ":", "604", ",")`;
    if [contains ($recommendations, $token)] {
      "1";
    } else {
      fragile-recommendation-applied-to-any (#candidates = `$candidates[position() > 1]`);
    }
  } else {
    "0";
  }
}

tpl consider-recommendation (#recommendation) {
  choose {
    when [$recommendation = "601"] { // chklab
      $message = "chklab recommendation accepted; rewriting justification.";
      msg $message;
      // nothing further to do
    }
    when [$recommendation = "604"] {
      // Check whether there is already a reference in the current
      // list of references to which we have already applied the 604
      // recommendation.  If there is none, then let's go for it.
      // Otherwise, don't do anything; we don't want to apply multiple
      // 604 recommendations because this can lead to trouble.
      $recommendation-already-applied = fragile-recommendation-applied-to-any (#candidates = `preceding-sibling::Local-Reference`);
      if [$recommendation-already-applied = "1"] {
        msg "We have already accepted a 604 recommendation for the current list of references; not rewriting...";
        apply [.] mode="copy";
      } else {
        $message = "604 recommendation accepted; rewriting justification.";
        msg $message;
        if [self::*[@spelling]] {
          $formula-name = `@spelling`;
          if [key ("labelled-formulas", $formula-name)] {
            for-each [key ("labelled-formulas", $formula-name)] {
              if [Straightforward-Justification] {
                for-each [Straightforward-Justification] {
                  apply [*] mode="copy";
                }
              } else {
                apply [.] (#message = "Error: we expected to find a Straightforward-Justification child of the current item, but there is none.") mode="die";
              }
            }
          } else {
            $error = `concat ("Error: we cannot find formula '", $formula-name, "'.")`;
            apply [.] (#message = $error) mode="die";
          }
        } else {
          apply [.] (#message = "Error: we cannot accept a 604 recommendation because the current node lacks a spelling attribute.") mode="die";
        }
      }
    }
    otherwise {
      $message = `concat ("Warning: Unable to make sense of the recommendation '", $recommendation, "'.")`;
      msg $message;
      apply [.] mode="copy";
    }
  }
}

tpl [Item[Proposition/Label[@spelling]]] {
  $line = `@line`;
  $col = `@col`;
  $pseudo-token = `concat (",", $line, ":", $col, ":")`;
  if [contains ($recommendations, $pseudo-token)] {
    $after-token = `substring-after ($recommendations, $pseudo-token)`;
    $recommendation = `substring-before ($after-token, ",")`;
    consider-recommendation (#recommendation = $recommendation);
  } else {
    apply [.] mode="copy";
  }
}

tpl [Local-Reference[@line and @col]] {
  $line = `@line`;
  $col = `@col`;
  $pseudo-token = `concat (",", $line, ":", $col, ":")`;
  if [contains ($recommendations, $pseudo-token)] {
    $after-token = `substring-after ($recommendations, $pseudo-token)`;
    $recommendation = `substring-before ($after-token, ",")`;
    consider-recommendation (#recommendation = $recommendation);
  } else {
    apply [.] mode="copy";
  }
}
