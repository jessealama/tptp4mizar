stylesheet "1.0";
include "tstp2wsx.xsl";
output method="xml" indent="yes";

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

tpl [formula[@name and source/non-logical-data[@name = "inference"]/non-logical-data[@name = "csr"]]] mode="lemma" {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label {
        $safe-name = capitalize-after-underscore (#string = `@name`);
        $step-name = `concat ("Step", $safe-name)`;
        @spelling = $step-name;
      }
      apply [*[1]] mode="strip-universal-prefix";
    }
    <Block {
      @kind = "Proof";
      for-each [source] {
        for-each [non-logical-data[@name = "inference"]] {
          for-each [non-logical-data[position() = last()]] {
            for-each [number[@name]] {
              $n = `@name`;
              $position = `position ()`;
              $dependent-formula = `key ("formulas", $n)`;
              choose {
                when [position() = 1] {
                  for-each [$dependent-formula] {
                    apply [.] mode="reiterate";
                  }
                }
                when [position() = 2] {
                  <Item {
                    @kind = "Conclusion";
                    @shape = "Compact-Statement";
                    <Proposition {
                      <Thesis;
                    }
                    <Straightforward-Justification {
                      <Link;
                      <Local-Reference {
                        for-each [$dependent-formula] {
                          $dependent-formula-name = `@name`;
                          if [@status = "axiom"] {
                            $safe-name = capitalize-after-underscore (#string = $dependent-formula-name);
                            $padded = pad-axiom (#string = $safe-name);
                            @spelling = $padded;
                          } else {
                            @spelling = `concat ("Step", $dependent-formula-name)`;
                          }
                        }
                      }
                    }
                  }
                }
                otherwise {
                  apply [.] mode="trace";
                  msg terminate="yes" "Error: we are dealing with a CSR inference having more than two premises.";
                }
              }
            }
          }
        }
      }
    }
  }
}

tpl [formula[@name and not(source/non-logical-data[@name = "inference"]/non-logical-data[@name = "csr"])]] mode="lemma" {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label {
        $safe-name = capitalize-after-underscore (#string = `@name`);
        $step-name = `concat ("Step", $safe-name)`;
        @spelling = $step-name;
      }
      apply [*[1]] mode="strip-universal-prefix";
    }
    <Straightforward-Justification {
      for-each [source] {
        for-each [non-logical-data[@name = "inference"]] {
          for-each [non-logical-data[position() = last()]] {
            for-each [number[@name]] {
              $n = `@name`;
              <Local-Reference {
                if [key ("axiom", $n)] {
                  for-each [key ("axiom", $n)] {
                    for-each [source] {
                      for-each [non-logical-data[@name = "file"]] {
                        for-each [non-logical-data[position() = last()]] {
                          $safe-name = capitalize-after-underscore (#string = `@name`);
                          $padded = pad-axiom (#string = $safe-name);
                          @spelling = $padded;
                        }
                      }
                    }
                  }
                } else {
                  $safe-name = capitalize-after-underscore (#string = `@name`);
                  $step-name = `concat ("Step", $safe-name)`;
                  @spelling = $step-name;
                }
              }
            }
          }
          if [non-logical-data[@name = "skolemize"]] {
            <Definition-Reference {
              @spelling = "SKOLEM";
              @"number" = `count (preceding::formula[source/non-logical-data[@name = "inference"]/non-logical-data[@name = "skolemize"]]) + 1`;
            }
          }
        }
      }
    }
  }
}
