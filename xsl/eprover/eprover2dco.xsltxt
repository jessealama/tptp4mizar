stylesheet "1.0";
include "../tstp/tstp2dco.xsl";
output method="xml" indent="yes";

//////////////////////////////////////////////////////////////////////
// Stylesheet parameters
//////////////////////////////////////////////////////////////////////

// The name of the article .dco that we will create
#only-skolems = { ""; }

// Whether to skip treating all skolems.  The only value recognized is
// '1'; anything else means that skolems will be considered.
#no-skolems = { ""; }

// Skolem prefix
#skolem-prefix = { "esk"; }

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

tpl [tstp] {
  $num-skolem-functions
    = `count(descendant::function[starts-with (@name, $skolem-prefix)
                                  and not(@name = preceding::function/@name)
                                  and not(@name = ancestor::function/@name)])`;
  $num-predicates
    = `count(descendant::predicate[not(@name = "=")
             and not(@name = preceding::predicate/@name)])`;
  $num-functions
    = `count(descendant::function[not(@name = preceding::function/@name)
                                  and not(@name = ancestor::function/@name)])`;
  $article-uc = uc (#s = `$article`);
  if [$only-skolems = "1"] {
    <Constructors {
      <Signature {
        <ArticleID {
          @"name" = "HIDDEN";
        }
      }
      <ConstrCounts {
        if [$num-skolem-functions > 0] {
          <ConstrCount {
            @kind = "K";
            @nr = `$num-skolem-functions`;
          }
        }
      }
      for-each [descendant::function[starts-with (@name, $skolem-prefix) and not(@name = preceding::function[@name]/@name) and not(@name = ancestor::function[@name]/@name)]] {
        <Constructor {
          @kind = "K";
          @nr = `position()`;
          @aid = `$article-uc`;
          @relnr = `position()`;
          @spelling = `@name`;
          <ArgTypes {
            for-each [*] {
              <Typ {
                @kind = "M";
                @nr = "1";
                <Cluster;
              }
            }
          }
          <Typ {
            @kind = "M";
            @nr = "1";
            <Cluster;
          }
        }
      }
    }
  } else {
    <Constructors {
      <Signature {
        <ArticleID {
          @"name" = "HIDDEN";
        }
      }
      <ConstrCounts {
        if [$num-predicates > 0] {
          <ConstrCount {
            @kind = "R";
            @nr = `$num-predicates`;
          }
        }
        if [$num-functions > 0] {
          <ConstrCount {
            @kind = "K";
            @nr = `$num-functions`;
          }
        }
      }
      for-each [descendant::function[@name and not(@name = preceding::function[@name]/@name) and not(@name = ancestor::function[@name]/@name)]] {
        <Constructor {
          @kind = "K";
          @nr = `position()`;
          @aid = `$article-uc`;
          @relnr = `position()`;
          @spelling = `@name`;
          <ArgTypes {
            for-each [*] {
              <Typ {
                @kind = "M";
                @nr = "1";
                <Cluster;
              }
            }
          }
          <Typ {
            @kind = "M";
            @nr = "1";
            <Cluster;
          }
        }
      }
      for-each [descendant::predicate[@name and not(@name = "=") and not(@name = preceding::predicate[@name]/@name)]] {
        <Constructor {
          @kind = "R";
          @nr = `position()`;
          @aid = `$article-uc`;
          @relnr = `2 + position()`;
          @spelling = `@name`;
          <ArgTypes {
            for-each [*] {
              <Typ {
                @kind = "M";
                @nr = "1";
                <Cluster;
              }
            }
          }
        }
      }
    }
  }
}
