stylesheet "1.0";
output method="xml" indent="yes";

//////////////////////////////////////////////////////////////////////
// Utilities
//////////////////////////////////////////////////////////////////////

tpl add-to-token-string (#item, #token-string) {
  $empty = token-string-is-empty (#token-string = $token-string);
  if [$empty = "1"] {
    `concat (",", $item, ",")`;
  } else {
    `concat (",", $item, $token-string)`;
  }
}

tpl token-string-is-empty (#token-string) {
  if [$token-string = ",,"] {
    "1";
  } else {
    "0";
  }
}

tpl append-token-strings (#a, #b) {
  $a-is-empty = token-string-is-empty (#token-string = $a);
  $b-is-empty = token-string-is-empty (#token-string = $b);
  choose {
    when [$a-is-empty = "1"] {
      $b;
    }
    when [$b-is-empty = "1"] {
      $a;
    }
    otherwise {
      $b-stripped = `substring-after ($b, ",")`;
      `concat ($a, $b-stripped)`;
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

tpl [*] mode="copy" {
  $n = `name (.)`;
  <$n {
    for-each [@*] { copy-of `.`; }
    apply [*] mode="copy";
  }
}

tpl [/] {
  apply [tstp];
}

// trim duplicates, remove weird formulas that are neither axioms nor
// derived from anything
tpl [tstp] {
  <tstp {
    for-each [formula[@status = "axiom" or status = "conjecture" or source/non-logical-data[@name = "inference"]][1]] {
      apply [.] (#same = ",,");
    }
  }
}

tpl [source[not(non-logical-data[@name = "inference"])]] mode="maybe-rewrite-references" {
  apply [.] mode="copy";
}

tpl [source[non-logical-data[@name = "inference"]]] (#same) mode="maybe-rewrite-references" {
  <source {
    <non-logical-data {
      @"name" = "inference";
      for-each [non-logical-data[@name = "inference"]] {
        for-each [non-logical-data[position() < last()]] {
          apply [.] mode="copy";
        }
        for-each [non-logical-data[position() = last()]] {
          <non-logical-data {
            for-each [number[@name]] {
              $formula-number = `@name`;
              $pseudo-token = `concat (",", $formula-number, ":")`;
              if [contains ($same, $pseudo-token)] {
                // we have seen before the formula that this one
                // depends on.
                $after-pseudo-token = `substring-after ($same, $pseudo-token)`;
                $earlier-formula-number = `substring-before ($after-pseudo-token, ",")`;
                <"number" {
                  @"name" = $earlier-formula-number;
                }
              } else {
                <"number" {
                  @"name" = $formula-number;
                }
              }
            }
          }
        }
      }
    }
  }
}

tpl [formula] (#same) mode="maybe-rewrite-references" {
  <formula {
    for-each [@*] { copy-of `.`; }
    apply [*[1]] mode="copy";
    apply [source] (#same = $same) mode="maybe-rewrite-references";
  }
}

tpl [formula[@name]] (#same) {
  $intro-message = `concat ("Here is the same string now: ", $same)`;
  msg $intro-message;
  $n = `@name`;
  $formula = `.`;
  $pseudo-token = `concat (",", $n, ":")`;
  if [contains ($same, $pseudo-token)] {
     // msg "not doing anything";
    // don't do anything: this formula is identical to one we've already seen
    apply [following-sibling::formula[@status = "axiom" or @status = "conjecture" or source/non-logical-data[@name = "inference"]][1]] (#same = $same);
  } else {
    apply [.] (#same = $same) mode="maybe-rewrite-references";
    $same-formulas = identical-formulas (#formula = $formula,
                                         #candidates = `following-sibling::formula[@status = "axiom" or @status = "conjecture" or source/non-logical-data[@name = "inference"]]`);
    $same-message = `concat ("Here are the formulas identical to ", $n, ": ", $same-formulas)`;
    // msg $same-message;
    $same-is-empty = token-string-is-empty (#token-string = $same-formulas);
    if [$same-is-empty = "1"] {
      apply [following-sibling::formula[@status = "axiom" or @status = "conjecture" or source/non-logical-data[@name = "inference"]][1]] (#same = $same);
    } else {
      $new-same = append-token-strings (#a = $same, #b = $same-formulas);
      apply [following-sibling::formula[@status = "axiom" or @status = "conjecture" or source/non-logical-data[@name = "inference"]][1]] (#same = $new-same);
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Identical formulas
//////////////////////////////////////////////////////////////////////

tpl identical-formulas (#formula, #candidates) {
  identical-formulas-1 (#formula = $formula,
  		        #candidates = $candidates,
			#same = ",,");
}

tpl identical-formulas-1 (#formula, #candidates, #same) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $remaining-candidates = `$candidates[position() > 1]`;
    $candidate-name = `$candidate/@name`;
    $formula-name = `$formula/@name`;
    $identical = identical-nodes (#a = `$formula/*[1]`,
    	       	 		  #b = `$candidate/*[1]`);
    $identical-message = `concat ("Are formulas ", $formula-name, " and ", $candidate-name, " identical? ", $identical)`;
    // msg $identical-message;
    if [$identical = "1"] {
      $token = `concat ($candidate-name, ":", $formula-name)`;
      $new-same = add-to-token-string (#item = $token,
      		  		       #token-string = $same);
      identical-formulas-1 (#formula = $formula,
      			    #candidates = $remaining-candidates,
			    #same = $new-same);
    } else {
      identical-formulas-1 (#formula = $formula,
      			    #candidates = $remaining-candidates,
			    #same = $same);
    }
  } else {
    $same;
  }
}

tpl identical-nodes (#a, #b) {
  $a-element-name = `name ($a)`;
  $b-element-name = `name ($b)`;
  $a-message = `concat ("a element name: ", $a-element-name)`;
  $b-message = `concat ("b element name: ", $b-element-name)`;
  // msg $a-message;
  // msg $b-message;
  $a-children = `$a/*`;
  $b-children = `$b/*`;
  if [$a-element-name = $b-element-name] {
    // msg "equal element names";
    choose {
      when [$a-element-name = "quantifier" and $b-element-name = "quantifier"] {
         $a-kind = `$a/@kind`;
         $b-kind = `$b/@kind`;
         if [$a-kind = $b-kind] {
           all-nodes-identical (#set-a = $a-children,
                                #set-b = $b-children);
         } else {
           "0";
         }
      }
      when [$a-element-name = "quantifier" and not($b-element-name = "quantifier")] {
        "0";
      }
      when [$b-element-name = "quantifier" and not($a-element-name = "quantifier")] {
        "0";
      }
      when [$a-element-name = "predicate" and $b-element-name = "predicate"] {
         $a-name = `$a/@name`;
         $b-name = `$b/@name`;
         if [$a-name = $b-name] {
           // msg "equal predicate names";
           all-nodes-identical (#set-a = $a-children,
                                #set-b = $b-children);
         } else {
           "0";
         }
      }
      when [$a-element-name = "function" and $b-element-name = "function"] {
         $a-name = `$a/@name`;
         $b-name = `$b/@name`;
         if [$a-name = $b-name] {
           // msg "testing children";
           all-nodes-identical (#set-a = $a-children,
                                #set-b = $b-children);
         } else {
           "0";
         }
      }
      when [$a-element-name = $b-element-name and not($a/@name) and not($b/@name)] {
         // msg "anonymous case";
         all-nodes-identical (#set-a = $a-children,
                              #set-b = $b-children);
      }
      otherwise {
        "0";
      }
    }
  } else {
    "0";
  }
}

tpl all-nodes-identical (#set-a, #set-b) {
  if [$set-a] {
    if [$set-b] {
      $a = `$set-a[1]`;
      $b = `$set-b[1]`;
      $same = identical-nodes (#a = $a, #b = $b);
      if [$same = "1"] {
        all-nodes-identical (#set-a = `$set-a[position() > 1]`,
			     #set-b = `$set-b[position() > 1]`);
      } else {
        "0";
      }
    } else {
      "0";
    }
  } else {
    if [$set-b] {
      "0";
    } else {
      "1";
    }
  }
}
