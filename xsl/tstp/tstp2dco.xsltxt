stylesheet "1.0";
include "../utils/strings.xsl";
output method="xml" indent="yes";
output omit-xml-declaration="no";

//////////////////////////////////////////////////////////////////////
// Stylesheet parameters
//////////////////////////////////////////////////////////////////////

// The name of the article .dco that we will create
#article = { ""; }

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

tpl [/] {
  choose {
    when [$article = ""] {
      msg terminate="yes" "Error: a value for the article stylesheet parameter was not supplied (or the empty string was supplied).";
    }
    when [not(tstp)] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it lacks a 'tstp' root element.";
    }
    when [tstp[2]] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it has multiple 'tstp' root elements.";
    }
    otherwise {
      apply [tstp];
    }
  }
}

tpl [tstp] {
  $num-predicates = `count(descendant::predicate[@name and not(@name = "=") and not(@name = preceding::predicate[@name]/@name)])`;
  $num-functions = `count(descendant::function[@name and not(@name = preceding::function[@name]/@name) and not(@name = ancestor::function[@name]/@name)])`;
  $article-uc = uc (#s = `$article`);
  <Constructors {
    <Signature {
      <ArticleID {
        @"name" = "HIDDEN";
      }
    }
    <ConstrCounts {
      <ConstrCount {
        @kind = "R";
        @nr = `$num-predicates`;
      }
       <ConstrCount {
        @kind = "K";
        @nr = `$num-functions`;
       }
    }

    for-each [descendant::predicate[not(@name = "=")
                                    and not(@name = preceding::predicate/@name)]] {
      apply [.] (#nr = `position ()`,
      	    	 #relnr = `position() + 2`,
		 #aid = $article-uc);
    }

    for-each [descendant::function[not(@name = preceding::function/@name)
                                   and not(@name = ancestor::function/@name)]] {
      apply [.] (#nr = `position ()`,
      	    	 #relnr = `position()`,
		 #aid = $article-uc);
    }

  }
}

tpl constructor (#kind, #nr, #relnr, #aid) {

}

tpl [function[@name]] (#nr, #relnr, #aid) {
  <Constructor {
    @kind = "K";
    @nr = $nr;
    @aid = $aid;
    @relnr = $relnr;
    // @spelling = `@name`;
    <ArgTypes {
      for-each [*] {
        <Typ {
          @kind = "M";
          @nr = "1";
          <Cluster;
        }
      }
    }
    <Typ {
      @kind = "M";
      @nr = "1";
      <Cluster;
    }
  }
}

tpl [predicate] (#nr, #relnr, #aid) {
  <Constructor {
    @kind = "R";
    @nr = $nr;
    @aid = $aid;
    @relnr = $relnr;
    // @spelling = `@name`;
    <ArgTypes {
      for-each [*] {
        <Typ {
          @kind = "M";
          @nr = "1";
          <Cluster;
        }
      }
    }
  }
}