stylesheet "1.0";
output method="xml" indent="yes";

//////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////

include "strings.xsl";

//////////////////////////////////////////////////////////////////////
// Stylesheet parameters
//////////////////////////////////////////////////////////////////////

#article = { ""; }

// Should be either "flat" or "nested"
#shape = { ""; }

//////////////////////////////////////////////////////////////////////
// Keys
//////////////////////////////////////////////////////////////////////

key "axiom" [formula[@name and @status = "axiom"]] `@name`;
key "formulas" [formula[@name]] `@name`;

//////////////////////////////////////////////////////////////////////
// Utilities
//////////////////////////////////////////////////////////////////////

tpl pad-axiom (#string) {
  `concat ("Axiom", $string)`;
}

tpl capitalize-after-underscore (#string) {
  if [contains ($string, "_")] {
    $before = `substring-before ($string, "_")`;
    $after = `substring-after ($string, "_")`;
    if [$after = ""] {
      `$before`;
    } else {
      $after-length = `string-length ($after)`;
      $first-char-as-string = `substring ($after, 1, 1)`;
      $after-first-char = `substring ($after, 2, $after-length)`;
      $first-char-as-string-uc = uc (#s = $first-char-as-string);
      $transformed-tail = capitalize-after-underscore (#string = $after-first-char);
      `concat ($before, $first-char-as-string-uc, $transformed-tail)`;
    }
  } else {
    `$string`;
  }
}

tpl [*] mode="trace" {
  $n = `name (.)`;
  $position = `count (preceding-sibling::*[name() = $n]) + 1`;
  if [parent::*] {
    apply [..] mode="trace";
  }
  $step = `concat ($n, "[", $position, "]")`;
  msg $step;
}

//////////////////////////////////////////////////////////////////////
// Keys
//////////////////////////////////////////////////////////////////////

key "axiom" [formula[@status = "axiom"]] `@name`;

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

// If we don't handle something explicitly, we don't handle it at all.
tpl [*] {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="no-justification" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in no-justification mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="negate-conjecture" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in negate-conjecture mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="strip-universal-prefix" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in strip-universal-prefix mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="axiom" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in axiom mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="lemma" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in lemma mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="conjecture" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in conjecture mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [*] mode="full" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in full mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

//////////////////////////////////////////////////////////////////////
// Business as usual
//////////////////////////////////////////////////////////////////////

tpl [/] {
  choose {
    when [$article = ""] {
      msg terminate="yes" "Error: the empty string is not an acceptable value for the article stylesheet parameter.";
    }
    when [string-length ($article) > 8] {
      msg terminate="yes" "Error: the value of the article stylesheet parameter is too long (it must be at most 8 characters).";
    }
    when [contains ($article, " ")] {
      msg terminate="yes" "Error: the value of the article stylesheet parameter contains whitespace.";
    }
    when [$shape = ""] {
      msg terminate="yes" "Error: a non-empty value for the shape stylesheet parameter is mandatory.";
    }
    when [not($shape = "flat") and not($shape = "nested")] {
      msg terminate="yes" "Error: the only permitted values of the shape stylesheet parameter are 'flat' and 'nested'.";
    }
    when [tstp] {
      apply [tstp];
    }
    otherwise {
      msg terminate="yes" "Error: the required tstp document element is missing.";
    }
  }
}

tpl [tstp[formula[@status = "conjecture"][2]]] {
  msg terminate="yes" "Error: there are multiple conjecture formulas, but we expected to find exactly one.";
}

tpl [tstp[not(formula[@status = "conjecture"])]] {
  msg terminate="yes" "Error: there is no conjecture formula.";
}

tpl reserve-variables {
  if [descendant::variable] {
    <Item {
      @kind = "Reservation";
      <Variables {
        for-each [descendant::variable[@name and not(@name = preceding::variable[@name]/@name)]] {
          <Variable {
            @spelling = `@name`;
          }
        }
      }
      <Standard-Type {
        @spelling = "set";
      }
    }
  }
}

tpl [tstp[formula[@status = "conjecture"]]] {
  $aid-uc = uc (#s = $article);
  <Text-Proper {
    @articleid = $aid-uc;
    <Item {
      @kind = "Section-Pragma";
    }
    reserve-variables ();
    choose {
      when [$shape = "flat"] {
        apply [.] mode="flat";
      }
      when [$shape = "nested"] {
        apply [.] mode="nested";
      }
      otherwise {
        $message = `concat ("Error: unknown shape '", $shape, "'.")`;
        msg terminate="yes" $message;
      }
    }
  }
}

tpl [tstp] mode="flat" {
  for-each [formula[@status = "axiom"]] {
    apply [.] mode="axiom";
  }
  <Item {
    @kind = "Regular-Statement";
    @shape = "Diffuse-Statement";
    <Label {
      @spelling = "Refutation";
    }
    <Block {
      @kind = "Now-Reasoning";
      for-each [formula[not(@status = "axiom") and not(@status = "conjecture") and source/non-logical-data[@name = "inference"]]] {
        choose {
          when [@status = "negated_conjecture" and not(preceding-sibling::formula[@status = "negated_conjecture"])] {
            <Item {
              @kind = "Assumption";
              <Single-Assumption {
                apply [.] mode="no-justification";
              }
            }
          }
          when [position() = last()] {
            apply [.] mode="conclusion";
          }
          otherwise {
            apply [.] mode="lemma";
          }
        }
      }
    }
  }
  <Item {
    @kind = "Theorem-Item";
    for-each [formula[@status = "conjecture"]] {
      <Proposition {
      apply [*[1]]; // render the formula
      }
    }
    <Straightforward-Justification {
      <Local-Reference {
        @spelling = "Refutation";
      }
    }
  }
}

tpl any-depends-on-conjecture (#formula-names) {
  if [$formula-names] {
    $formula-name = `$formula-names[1]`;
    if [key ("formulas", $formula-name)] {
      for-each [key ("formulas", $formula-name)] {
        $depends = depends-on-conjecture ();
        if [$depends = "1"] {
          "1";
        } else {
          any-depends-on-conjecture (#formula-names = `$formula-names[position() > 1]`);
        }
      }
    } else {
      $message = `concat ("Error: unknown formula '", $formula-name, "'.")`;
      apply [.] mode="trace";
      msg terminate="yes" $message;
    }
  } else {
    "0";
  }
}

tpl depends-on-conjecture {
  if [self::formula[@status = "conjecture"]] {
    "1";
  } else {
    for-each [source] {
      if [non-logical-data[@name = "inference"]] {
        for-each [non-logical-data[@name = "inference"]] {
          for-each [non-logical-data[position() = last()]] {
            any-depends-on-conjecture (#formula-names = `number[@name]/@name`);
          }
        }
      } else {
        "0";
      }
    }
  }
}

tpl [tstp] mode="nested" {
  for-each [formula[@status = "axiom"]] {
    apply [.] mode="axiom";
  }
  for-each [formula[not(@status = "axiom") and source/non-logical-data[@name = "inference"]]] {
    $depends-on-conjecture = depends-on-conjecture ();
    if [$depends-on-conjecture = "0"] {
      apply [.] mode="lemma";
    }
  }
  for-each [formula[@status = "conjecture"]] {
    apply [.] mode="conjecture";
  }
}

tpl [formula[@name]] mode="axiom" {
  // at the moment we cannot handle axioms in the usual sense, so we
  // will treat axioms as lemmas
  $n = `@name`;
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label {
          for-each [source] {
          for-each [non-logical-data[@name = "file"]] {
            for-each [non-logical-data[position() = last()]] {
              $safe-name = capitalize-after-underscore (#string = `@name`);
              $padded = pad-axiom (#string = $safe-name);
              @spelling = $padded;
            }
          }
        }
      }
        apply [*[1]] mode="strip-universal-prefix";
    }
    <Straightforward-Justification {
      <Theorem-Reference {
        $article-uc = uc (#s = $article);
        @spelling = $article-uc;
	@"number" = `count (preceding::formula[@status = "axiom"]) + 1`;
      }
    }
  }
}

tpl [*] mode="reiterate" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in reiterate mode.")`;
  apply [.] mode="trace";
  msg terminate="yes" $message;
}

tpl [formula] mode="reiterate" {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      apply [*[1]] mode="strip-universal-prefix";
    }
    <Straightforward-Justification {
      if [@status = "axiom"] {
        $safe-name = capitalize-after-underscore (#string = `@name`);
        $padded = pad-axiom (#string = $safe-name);
        @spelling = $padded;
      } else {
        <Local-Reference {
          $n = `@name`;
          @spelling = `concat ("Step", $n)`;
        }
      }
    }
  }
}

tpl [formula[@name and source/non-logical-data[@name = "inference"]]] mode="lemma" {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label {
        $safe-name = capitalize-after-underscore (#string = `@name`);
        $step-name = `concat ("Step", $safe-name)`;
        @spelling = $step-name;
      }
      apply [*[1]] mode="strip-universal-prefix";
    }
    <Straightforward-Justification {
      for-each [source] {
        for-each [non-logical-data[@name = "inference"]] {
          for-each [non-logical-data[position() = last()]] {
            for-each [number[@name]] {
              $n = `@name`;
              <Local-Reference {
                if [key ("axiom", $n)] {
                  for-each [key ("axiom", $n)] {
                    for-each [source] {
                      for-each [non-logical-data[@name = "file"]] {
                        for-each [non-logical-data[position() = last()]] {
                          $safe-name = capitalize-after-underscore (#string = `@name`);
                          $padded = pad-axiom (#string = $safe-name);
                          @spelling = $padded;
                        }
                      }
                    }
                  }
                } else {
                  $safe-name = capitalize-after-underscore (#string = `@name`);
                  $step-name = `concat ("Step", $safe-name)`;
                  @spelling = $step-name;
                }
              }
            }
          }
          if [non-logical-data[@name = "skolemize"]] {
            <Definition-Reference {
              @spelling = "SKOLEM";
              @"number" = `count (preceding::formula[source/non-logical-data[@name = "inference"]/non-logical-data[@name = "skolemize"]]) + 1`;
            }
          }
        }
      }
    }
  }
}

tpl [formula] mode="conjecture" {
  <Item {
    @kind = "Theorem-Item";
    <Proposition {
      apply [*[1]]; // render the formula
    }
    <Block {
      @kind = "Proof";
      <Block {
        @kind = "Now-Reasoning";
        <Item {
          @kind = "Assumption";
          <Single-Assumption {
            apply [following-sibling::formula[@status = "negated_conjecture"][1]] mode="no-justification";
          }
        }
        for-each [following-sibling::formula[not(@status = "axiom") and source/non-logical-data[@name = "inference"]]] {
          choose {
            when [@status = "negated_conjecture" and not(preceding-sibling::formula[@status = "negated_conjecture"])] {
              // ignore; we just dealt with this particular formula
            }
            when [position() = last()] {
              apply [.] mode="conclusion";
            }
            otherwise {
              $depends = depends-on-conjecture ();
              if [$depends = "1"] {
                apply [.] mode="full";
              }
            }
          }
        }
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        <Proposition {
          <Thesis;
        }
        <Straightforward-Justification {
          <Link;
        }
      }
    }
  }
}

tpl [formula[@name and not(@name = "")]] mode="no-justification" {
  <Proposition {
    <Label {
      $safe-name = capitalize-after-underscore (#string = `@name`);
      $step-name = `concat ("Step", $safe-name)`;
      @spelling = $step-name;
    }
    apply [*[1]];
  }
}

tpl [formula[@name and not(@name = "")]] mode="no-label" {
  <Proposition {
    apply [*[1]];
  }
}

tpl [formula[@name and not(@name = "")]] mode="conclusion" {
  <Item {
    @kind = "Conclusion";
    @shape = "Compact-Statement";
    <Proposition {
      apply [*[1]];
    }
    <Straightforward-Justification {
      for-each [source] {
        choose {
          when [number[@name]] {
            for-each [number[@name]] {
              $n = `@name`;
              <Local-Reference {
                if [key ("axiom", $n)] {
                  for-each [key ("axiom", $n)] {
                    for-each [source] {
                      for-each [non-logical-data[@name = "file"]] {
                        for-each [non-logical-data[position() = last()]] {
                          $safe-name = capitalize-after-underscore (#string = `@name`);
                          $padded = pad-axiom (#string = $safe-name);
                          @spelling = $padded;
                        }
                      }
                    }
                  }
                } else {
                  $safe-name = capitalize-after-underscore (#string = $n);
                  $step-name = `concat ("Step", $safe-name)`;
                  @spelling = $step-name;
                }
              }
            }
          }
          when [non-logical-data[@name = "inference"]] {
            for-each [non-logical-data[@name = "inference"]] {
              for-each [non-logical-data[position() = last()]] {
                for-each [number[@name]] {
                  <Local-Reference {
                    $n = `@name`;
                    if [key ("axiom", $n)] {
                      for-each [key ("axiom", $n)] {
                        for-each [source] {
                          for-each [non-logical-data[@name = "file"]] {
                            for-each [non-logical-data[position() = last()]] {
                              $safe-name = capitalize-after-underscore (#string = `@name`);
                              $padded = pad-axiom (#string = $safe-name);
                              @spelling = $padded;
                            }
                          }
                        }
                      }
                    } else {
                      $safe-name = capitalize-after-underscore (#string = $n);
                      $step-name = `concat ("Step", $safe-name)`;
                      @spelling = $step-name;
                    }
                  }
                }
              }
              if [non-logical-data[@name = "skolemize"]] {
                <Definition-Reference {
                  @spelling = "SKOLEM";
                  @"number" = `count (preceding::formula[source/non-logical-data[@name = "inference"]/non-logical-data[@name = "skolemize"]]) + 1`;
                }
              }
            }
          }
          otherwise {
            apply [.] mode="trace";
            msg terminate="yes" "Error: Unable to figure out how to deal with the justification of a formula";
          }
        }
      }
    }
  }
}



tpl [formula[@name and not(@name = "")]] mode="full" {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label {
        $safe-name = capitalize-after-underscore (#string = `@name`);
        $step-name = `concat ("Step", $safe-name)`;
        @spelling = $step-name;
      }
      apply [*[1]] mode="strip-universal-prefix";
    }
    <Straightforward-Justification {
      for-each [source] {
        choose {
          when [number[@name]] {
            for-each [number[@name]] {
              $n = `@name`;
              <Local-Reference {
                if [key ("axiom", $n)] {
                  for-each [key ("axiom", $n)] {
                    for-each [source] {
                      for-each [non-logical-data[@name = "file"]] {
                        for-each [non-logical-data[position() = last()]] {
                          $safe-name = capitalize-after-underscore (#string = `@name`);
                          $padded = pad-axiom (#string = $safe-name);
                          @spelling = $padded;
                        }
                      }
                    }
                  }
                } else {
                  $safe-name = capitalize-after-underscore (#string = $n);
                  $step-name = `concat ("Step", $safe-name)`;
                  @spelling = $step-name;
                }
              }
            }
          }
          when [non-logical-data[@name = "inference"]] {
            for-each [non-logical-data[@name = "inference"]] {
              for-each [non-logical-data[position() = last()]] {
                for-each [number[@name]] {
                  <Local-Reference {
                    $n = `@name`;
                    if [key ("axiom", $n)] {
                      for-each [key ("axiom", $n)] {
                        for-each [source] {
                          for-each [non-logical-data[@name = "file"]] {
                            for-each [non-logical-data[position() = last()]] {
                              $safe-name = capitalize-after-underscore (#string = `@name`);
                              $padded = pad-axiom (#string = $safe-name);
                              @spelling = $padded;
                            }
                          }
                        }
                      }
                    } else {
                      $safe-name = capitalize-after-underscore (#string = $n);
                      $step-name = `concat ("Step", $safe-name)`;
                      @spelling = $step-name;
                    }
                  }
                }
              }
              if [non-logical-data[@name = "skolemize"]] {
                <Definition-Reference {
                  @spelling = "SKOLEM";
                  @"number" = `count (preceding::formula[source/non-logical-data[@name = "inference"]/non-logical-data[@name = "skolemize"]]) + 1`;
                }
              }
            }
          }
          otherwise {
            apply [.] mode="trace";
            msg terminate="yes" "Error: Unable to figure out how to deal with the justification of a formula";
          }
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Terms
//////////////////////////////////////////////////////////////////////

tpl [variable[@name and not(@name = "")]] {
  <Variable {
    @spelling = `@name`;
  }
}

tpl [function[@name and not(@name = "")]] {
  <Infix-Term {
    @spelling = `@name`;
    <Arguments;
    <Arguments {
      apply [*];
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Formulas
//////////////////////////////////////////////////////////////////////

tpl [*] mode="strip-universal-prefix" {
  apply [.]; // if we don't handle it, just move along
}

tpl [quantifier[@type = "universal"]] mode="strip-universal-prefix" {
  apply [*[position() = last()]] mode="strip-universal-prefix";
}

tpl [quantifier[@type = "universal"]] (#started, #variables) {
  if [$started = "1"] {
    if [$variables] {
      $variable = `$variables[1]`;
      <Universal-Quantifier-Formula {
        <Implicitly-Qualified-Segment {
          apply [$variable];
        }
        apply [.] (#started = "1",
	      	   #variables = `$variables[position() > 1]`);
      }
    } else {
      apply [*[position() = last()]];
    }
  } else {
    apply [.] (#started = "1",
    	       #variables = `variable`);
  }
}

tpl [quantifier[@type = "existential"]] (#started, #variables) {
  if [$started = "1"] {
    if [$variables] {
      $variable = `$variables[1]`;
      <Existential-Quantifier-Formula {
        <Implicitly-Qualified-Segment {
          apply [$variable];
        }
        apply [.] (#started = "1",
	      	   #variables = `$variables[position() > 1]`);
      }
    } else {
      apply [*[position() = last()]];
    }
  } else {
    apply [.] (#started = "1",
    	       #variables = `variable`);
  }
}

tpl [implication[count(*) = 2]] {
  <Conditional-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [equivalence[count(*) = 2]] {
  <Biconditional-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [negation[count(*) = 1]] {
  <Negated-Formula {
    apply [*[1]];
  }
}

tpl [conjunction[count(*) = 2]] {
  <Conjunctive-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [disjunction[count(*) = 2]] {
  <Disjunctive-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [predicate[@name = "="]] {
  <Predicative-Formula {
    @spelling = "=";
    <Arguments {
      apply [*[1]];
    }
    <Arguments {
      apply [*[2]];
    }
  }
}

tpl [predicate[@name and not(@name = "=")]] {
  <Predicative-Formula {
    @spelling = `@name`;
    <Arguments;
    <Arguments {
      apply [*];
    }
  }
}

tpl [defined-predicate[@name = "true"]] {
  <Negated-Formula {
    <Contradiction;
  }
}

tpl [defined-predicate[@name = "false"]] {
  <Contradiction;
}
