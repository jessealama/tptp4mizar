stylesheet "1.0";
output method="xml" indent="yes";

//////////////////////////////////////////////////////////////////////
// Stylesheet parameters
//////////////////////////////////////////////////////////////////////

// A comma-delimited string (that also starts and ends
// with a comma) of the order of the nodes that we should print
#ordering = { ""; }

//////////////////////////////////////////////////////////////////////
// Token string utilities
//////////////////////////////////////////////////////////////////////

tpl token-string-is-empty (#token-string) {
  if [$token-string = ",,"] {
    "1";
  } else {
    "0";
  }
}

tpl token-string-tail (#token-string) {
  if [starts-with ($token-string, ",")] {
    $after-first-comma = `substring-after ($token-string, ",")`;
    if [contains ($after-first-comma, ",")] {
      $after-second-comma = `substring-after ($after-first-comma, ",")`;
      if [$after-second-comma = ""] {
        ",,";
      } else {
        `concat (",", $after-second-comma)`;
      }
    } else {
    $message = `concat ("We cannot take the tail of the token string '", $token-string, "': since it does not contain at least two commas")`;
    msg terminate="yes" $message;
    }
  } else {
    $message = `concat ("We cannot take the tail of the token string '", $token-string, "': since it does not begin with a comma, it is not actually a valid token string")`;
    msg terminate="yes" $message;
  }
}

tpl token-string-head (#token-string) {
  if [starts-with ($token-string, ",")] {
    $after-first-comma = `substring-after ($token-string, ",")`;
    if [contains ($after-first-comma, ",")] {
      $after-second-comma = `substring-after ($after-first-comma, ",")`;
      if [$after-second-comma = ""] {
        msg terminate="yes" "Error: cannot take the head of an empty token string.";
      } else {
        `substring-before ($after-first-comma, ",")`;
      }
    } else {
      $message = `concat ("We cannot take the head of the token string '", $token-string, "': since it does not contain at least two commas")`;
      msg terminate="yes" $message;
    }
  } else {
    $message = `concat ("We cannot take the head of the token string '", $token-string, "': since it does not begin with a comma, it is not actually a valid token string")`;
    msg terminate="yes" $message;
  }
}

// Determine whether $string is actually a token string.  This means that it is either empty or (i) begins with a comma, (ii) contains a second comma, (iii) the substring between the first and second comma is non-empty, and (iv) the substring starting at the second comma is a valid token string.
tpl is-valid-token-string (#string) {
  if [$string = ""] {
    "1";
  } else {
    if [starts-with ($string, ",")] {
      $after-first-comma = `substring-after ($string, ",")`;
      $between-first-and-second-comma = `substring-before ($after-first-comma, ",")`;
      if [$between-first-and-second-comma = ""] {
        "0";
      } else {
        $after-second-comma = `substring-after ($after-first-comma, ",")`;
        if [$after-second-comma = ""] {
          "1";
        } else {
          $tail = `concat (",", $after-second-comma)`;
          is-valid-token-string (#string = $tail);
        }
      }
    } else {
      "0";
    }
  }
}

// If we don't handle something explicitly, we don't handle it at all.
tpl [*] {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node.")`;
  msg terminate="yes" $message;
}

tpl [/] {
  if [tstp] {
    $ordering-ok = is-valid-token-string (#token-string = $ordering);
    if [$ordering-ok = "1"] {
      <tstp {
        for-each [@*] { copy-of `.`; }
        apply [tstp] (#token-string = $ordering);
      }
    } else {
      msg terminate="yes" "Error: the given ordering is not a valid token string.";
    }
  } else {
    msg terminate="yes" "Error: the required tstp document element is missing.";
  }
}

tpl [tstp] (#token-string) {
  $num-formulas = `count (formula)`;
  $num-commas-expected = `$num-formulas + 1`;
  $empty = token-string-is-empty (#token-string = $token-string);
  if [$empty = "1"] {
    // we are done
  } else {
    $head = token-string-head (#token-string = $token-string);
    $tail = token-string-tail (#token-string = $token-string);
    for-each [formula[@name = $head]] {
      apply [.];
    }
    apply [.] (#token-string = $tail);
  }
}

tpl [formula] {
  copy-of `.`;
}