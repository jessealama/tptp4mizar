stylesheet "1.0";
output method="xml" indent="yes";

tpl [*] mode="trace" {
  $n = `name (.)`;
  $position = `count (preceding-sibling::*[name() = $n]) + 1`;
  if [parent::*] {
    apply [..] mode="trace";
  }
  $step = `concat ($n, "[", $position, "]")`;
  msg $step;
}

// If we don't handle something explicitly, we don't handle it at all.
tpl [*] {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node.")`;
  msg terminate="yes" $message;
}

tpl [*] mode="no-justification" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in no-justification mode.")`;
  msg terminate="yes" $message;
}

tpl [*] mode="axiom" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in axiom mode.")`;
  msg terminate="yes" $message;
}

tpl [*] mode="lemma" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in lemma mode.")`;
  msg terminate="yes" $message;
}

tpl [*] mode="conjecture" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in conjecture mode.")`;
  msg terminate="yes" $message;
}

tpl [*] mode="full" {
  $n = `name (.)`;
  $message = `concat ("Error: we have arrived at an unhandled ", $n, " node in full mode.")`;
  msg terminate="yes" $message;
}

tpl [/] {
  if [tstp] {
    apply [tstp];
  } else {
    msg terminate="yes" "Error: the required tstp document element is missing.";
  }
}

tpl [tstp] {
  choose {
    when [formula[@status = "conjecture"][2]] {
      msg terminate="yes" "Error: there are multiple conjecture formulas, but we expected to find exactly one.";
    }
    when [formula[@status = "conjecture"]] {
      <Text-Proper {
        for-each [formula[@status = "conjecture"]] {
          for-each [preceding-sibling::formula[@status = "axiom"]] {
            sort order="ascending";
            apply [.] mode="axiom";
          }
          for-each [preceding-sibling::formula[not(@status = "axiom")]] {
            sort order="ascending";
            apply [.] mode="lemma";
          }
          apply [.] mode="conjecture";
        }
      }
    }
    otherwise {
      msg terminate="yes" "Error: there is no conjecture formula.";
    }
  }
}

tpl [formula[@name]] mode="axiom" {
  // at the moment we cannot handle axioms in the usual sense, so we
  // will treat axioms as lemmas
  apply [.] mode="lemma";
}

tpl [formula[@name]] mode="lemma" {
  <Fug;
}

tpl [formula] mode="conjecture" {
  <Item {
    @kind = "Theorem-Item";
    <Proposition {
      apply [*[1]]; // render the formula
    }
    <Block {
      @kind = "Proof";
      <Item {
        @kind = "Assumption";
        <Single-Assumption {
          apply [following-sibling::formula[@status = "negated_conjecture"][1]] mode="no-justification";
        }
      }
      for-each [following-sibling::formula[@status = "negated_conjecture"][position() > 1]] {
        apply [.] mode="full"; // "full" == label, proposition, justification
      }
      <Item {
        @kind = "Conclusion";
        @shape = "Compact-Statement";
        <Proposition {
          <Thesis;
        }
        <Straightforward-Justification {
          <Local-Reference {
            for-each [following-sibling::formula[@name and @status = "negated_conjecture"][position() = last()]] {
              @spelling = `@name`;
            }
          }
        }
      }
    }
  }
}

tpl [formula[@name and not(@name = "")]] mode="no-justification" {
  <Proposition {
    <Label {
      @spelling = `@name`;
    }
    apply [*[1]];
  }
}

tpl [formula[@name and not(@name = "")]] mode="full" {
  <Item {
    @kind = "Regular-Statement";
    @shape = "Compact-Statement";
    <Proposition {
      <Label {
        @spelling = `@name`;
      }
      apply [*[1]];
    }
    <Straightforward-Justification {
      for-each [source] {
        choose {
          when [number[@name]] {
            for-each [number[@name]] {
              <Local-Reference {
                @spelling = `@name`;
              }
            }
          }
          when [non-logical-data[@name = "inference"]] {
            for-each [non-logical-data[@name = "inference"]] {
              for-each [non-logical-data[position() = last()]] {
                for-each [number[@name]] {
                  <Local-Reference {
                    @spelling = `@name`;
                  }
                }
              }
            }
          }
          otherwise {
            apply [.] mode="trace";
            msg terminate="yes" "Error: Unable to figure out how to deal with the justification of a formula";
          }
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Terms
//////////////////////////////////////////////////////////////////////

tpl [variable[@name and not(@name = "")]] {
  <Variable {
    @spelling = `@name`;
  }
}

tpl [function[@name and not(@name = "")]] {
  <Infix-Term {
    @spelling = `@name`;
    <Arguments;
    <Arguments {
      apply [*];
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Formulas
//////////////////////////////////////////////////////////////////////

tpl [quantifier[@type = "universal"]] {
  <Universal-Quantifier-Formula {
    for-each [variable] {
      <Implicitly-Qualified-Segment {
        apply [.];
      }
    }
    apply [*[position() = last()]];
  }
}

tpl [quantifier[@type = "existential"]] {
  <Existential-Quantifier-Formula {
    for-each [variable] {
      <Implicitly-Qualified-Segment {
        apply [.];
      }
    }
    apply [*[position() = last()]];
  }
}

tpl [implication[count(*) = 2]] {
  <Conditional-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [negation[count(*) = 1]] {
  <Negated-Formula {
    apply [*[1]];
  }
}

tpl [conjunction[count(*) = 2]] {
  <Conjunctive-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [disjunction[count(*) = 2]] {
  <Disjunctive-Formula {
    apply [*[1]];
    apply [*[2]];
  }
}

tpl [predicate[@name]] {
  <Predicative-Formula {
    @spelling = `@name`;
    <Arguments;
    <Arguments {
      apply [*];
    }
  }
}

tpl [defined-predicate[@name = "true"]] {
  <Negated-Formula {
    <Contradiction;
  }
}

tpl [defined-predicate[@name = "false"]] {
  <Contradiction;
}
